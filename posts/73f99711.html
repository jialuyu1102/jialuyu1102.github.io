<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring MVC | JLY的小窝</title><meta name="author" content="JLY"><meta name="copyright" content="JLY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring MVC">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring MVC">
<meta property="og:url" content="http://example.com/posts/73f99711.html">
<meta property="og:site_name" content="JLY的小窝">
<meta property="og:description" content="Spring MVC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/852513f5970b000c44741ea6751bbf4a.png">
<meta property="article:published_time" content="2024-08-19T23:56:08.000Z">
<meta property="article:modified_time" content="2024-08-20T00:05:05.614Z">
<meta property="article:author" content="JLY">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Spring MVC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/852513f5970b000c44741ea6751bbf4a.png"><link rel="shortcut icon" href="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/%E5%9B%BE%E6%A0%87.png"><link rel="canonical" href="http://example.com/posts/73f99711.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"JY2YQT4F25","apiKey":"2fbf3647b8c7f04346c64c9ede0a0124","indexName":"hexo_blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"最后一次更新为","messageNext":"天前,文章内容可能已过期."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: JLY","link":"链接: ","source":"来源: JLY的小窝","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring MVC',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-20 08:05:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/config/css/style.css?1"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="JLY的小窝" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/852513f5970b000c44741ea6751bbf4a.png')"><nav id="nav"><span id="blog-info"><a href="/" title="JLY的小窝"><span class="site-name">JLY的小窝</span></a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><!-- span=' '+_p('search.title')--></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring MVC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-19T23:56:08.000Z" title="发表于 2024-08-20 07:56:08">2024-08-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-20T00:05:05.614Z" title="更新于 2024-08-20 08:05:05">2024-08-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/">Java技术栈</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring MVC"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><!-- if is_home()// #home_top--><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/852513f5970b000c44741ea6751bbf4a.png)"></div><article class="post-content" id="article-container"><h1 id="Spring整合web环境"><a href="#Spring整合web环境" class="headerlink" title="Spring整合web环境"></a>Spring整合web环境</h1><ol>
<li>Javaweb三大组件及环境特点</li>
</ol>
<p>在Java语言范畴内，web层框架都是基于Javaweb基础组件完成的，所以有必要复习一下Javaweb组件的特点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Servlet</td>
<td>服务端小程序，负责接收客户端 请求并作出响应的</td>
<td>单例对象，默认第一次访问创建，可以通过配置指定服务器启动就创建，Servlet 创建完毕会执行初始化init方法。每个Servlet有一个service方法，每次访问都会 执行service方法，但是缺点是一个业务功能就需要配置一个Servlet</td>
</tr>
<tr>
<td>Filter</td>
<td>过滤器，负责对客户端请求进行 过滤操作的</td>
<td>单例对象，服务器启动时就创建，对象创建完毕执行init方法，对客户端的请求 进行过滤，符合要求的放行，不符合要求的直接响应客户端，执行过滤的核心 方法doFilter</td>
</tr>
<tr>
<td>Listener</td>
<td>监听器，负责对域对象的创建和 属性变化进行监听的</td>
<td>根据类型和作用不同，又可分为监听域对象创建销毁和域对象属性内容变化的， 根据监听的域不同，又可以分为监听Request域的，监听Session域的，监听 ServletContext域的</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>Spring整合web环境的思路及实现</li>
</ol>
<p>在进行Java开发时要遵循三层架构+MVC，Spring操作最核心的就是Spring容器，web层需要注入Service， service层需要注入Dao（Mapper），web层使用Servlet技术充当的话，需要在Servlet中获得Spring容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ApplicationContextConfig.class);</span><br><span class="line"><span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> (AccountService)applicationContext.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">accountService.transferMoney(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;lucy&quot;</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>web层代码如果都去编写创建AnnotationConfigApplicationContext的代码，那么配置类重复被加载了， Spring容器也重复被创建了，不能每次想从容器中获得一个Bean都得先创建一次容器，这样肯定是不允许。 所以，我们现在的诉求很简单，如下：</p>
<ul>
<li>ApplicationContext创建一次，配置类加载一次;</li>
<li>最好web服务器启动时，就执行第1步操作，后续直接从容器中获取Bean使用即可;</li>
<li>ApplicationContext的引用需要在web层任何位置都可以获取到。</li>
</ul>
<p>针对以上诉求我们给出解决思路，如下：</p>
<ul>
<li>在ServletContextListener的contextInitialized方法中执行ApplicationContext的创建。或在Servlet的init 方法中执行ApplicationContext的创建，并给Servlet的load-on-startup属性一个数字值，确保服务器启动 Servlet就创建;</li>
<li>将创建好的ApplicationContext存储到ServletContext域中，这样整个web层任何位置就都可以获取到了</li>
</ul>
<ol>
<li>Spring的web开发组件spring-web</li>
</ol>
<p>到此，就将一开始的诉求都解决了，当然我们能想到的Spring 框架自然也会想到，Spring其实已经为我们定义 好了一个ContextLoaderListener，使用方式跟我们上面自己定义的大体一样，但是功能要比我们强百倍，所以 ，遵循Spring “拿来主义” 的精神，我们直接使用Spring提供的就可以了，开发如下：</p>
<ul>
<li>先导入Spring-web的坐标：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在web.xml中去配置ContextLoaderListener，并指定配置文件的位置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在Servlet中直接使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/accountServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> </span><br><span class="line">ServletException, IOException &#123;</span><br><span class="line">	<span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">	<span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> </span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">	<span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> applicationContext.getBean(AccountService.class);</span><br><span class="line">	accountService.transferMoney(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;lucy&quot;</span>,<span class="number">500</span>);&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注解形式</li>
</ul>
<p>如果核心配置类使用的是注解形式的，那么Spring容器是AnnotationConfigWebApplicationContext，如下配 置方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationConfigWebApplicationContext</span> <span class="keyword">extends</span> </span><br><span class="line"><span class="title class_">AnnotationConfigWebApplicationContext</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyAnnotationConfigWebApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//注册核心配置类</span></span><br><span class="line">		<span class="built_in">super</span>.register(ApplicationContextConfig.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itheima.web.MyAnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="web层MVC框架思想与设计思路"><a href="#web层MVC框架思想与设计思路" class="headerlink" title="web层MVC框架思想与设计思路"></a>web层MVC框架思想与设计思路</h1><p>MVC框架思想及其设计思路</p>
<p>Java程序员在开发一般都是MVC+三层架构，MVC是web开发模式，传统的Javaweb技术栈实现的MVC如下</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819211300969.png" alt="image-20240819211300969"></p>
<p>原始Javaweb开发中，Servlet充当Controller的角色，Jsp充当View角色，JavaBean充当模型角色，后期Ajax异 步流行后，在加上现在前后端分离开发模式成熟后，View就被原始Html+Vue替代。原始Javaweb开发中， Service充当Controller有很多弊端，显而易见的有如下几个：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Servlet作为Controller的问题</th>
<th>解决思路和方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>每个业务功能请求都对应一个Servlet</td>
<td>根据业务模块去划分Controller</td>
</tr>
<tr>
<td>每个Servlet的业务操作太繁琐</td>
<td>将通用的行为，功能进行抽取封装</td>
</tr>
<tr>
<td>Servlet获得Spring容器的组件只能通过客户端代码去获取，不能 优雅的整合</td>
<td>通过Spring的扩展点，去封装一个框架，从原有的Servlet完全接 手过来web层的业务</td>
</tr>
</tbody>
</table>
</div>
<p>负责共有行为的Servlet称之为前端控制器，负责业务行为的JavaBean称之为控制器Controller</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819211409958.png" alt="image-20240819211409958"></p>
<p>分析前端控制器基本功能如下：</p>
<p>1、具备可以映射到业务Bean的能力</p>
<p>2、具备可以解析请求参数、封装实体 等共有功能</p>
<p>3、具备响应视图及响应其他数据的功能</p>
<h1 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h1><p>SpringMVC是一个基于Spring开发的MVC轻量级框架，Spring3.0后发布的组件，SpringMVC和Spring可以无 缝整合，使用DispatcherServlet作为前端控制器，且内部提供了处理器映射器、处理器适配器、视图解析器等组 件，可以简化JavaBean封装，Json转化、文件上传等操作。</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819211500887.png" alt="image-20240819211500887"></p>
<h2 id="SpringMVC快速入门"><a href="#SpringMVC快速入门" class="headerlink" title="SpringMVC快速入门"></a>SpringMVC快速入门</h2><p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819211535062.png" alt="image-20240819211535062"></p>
<p>导入Spring整合SpringMVC的坐标</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写一个控制器Controller，配置映射信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"> 	<span class="meta">@RequestMapping(&quot;/show&quot;)</span></span><br><span class="line"> 	<span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;show 执行....&quot;</span>);</span><br><span class="line"> 		<span class="comment">//视图跳转到index.jsp</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在web.xml中配置SpringMVC的前端控制器ServletDispatcher</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--指定springMVC配置文件位置--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--服务器启动就创建--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建springMVC的核心配置文件 spring-mvc.xml，并配置组件扫描web层</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"> 		<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/xmlSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"> 		<span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag"> 		<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag"> 		http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag"> 		http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag"> 		http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="comment">&lt;!-- 组件扫描web层 --&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.controller&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Controller中访问容器中的Bean"><a href="#Controller中访问容器中的Bean" class="headerlink" title="Controller中访问容器中的Bean"></a>Controller中访问容器中的Bean</h2><p>DispatcherServlet在进行初始化时，加载的spring-mvc.xml配置文件创建的SpringMVC容器，那么web层 Controller被扫描进入到了容器中，而之前Spring容器中的Service是否可以获取到呢？下面搭建Spring的web环 境进行验证</p>
<p>创建一个applicationContext.xml文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描非web层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--排除com.itheima包下使用@Controller注解的类--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在web.xml中配置ContextLoaderListener</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置ContextLoaderListener--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applictionContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写UserService和UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;&#125;</span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;UserServiceImpl show running ... ...&quot;</span>);</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>修改UserController，从Spring容器中匹配Service进行注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UserService userService;</span><br><span class="line">         <span class="meta">@RequestMapping(&quot;/show&quot;)</span></span><br><span class="line">         <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;show 执行....&quot;</span>);</span><br><span class="line">         <span class="comment">//调用userService的show方法</span></span><br><span class="line">         userService.show();</span><br><span class="line">         <span class="comment">//视图跳转到index.jsp</span></span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SpringMVC关键组件浅析"><a href="#SpringMVC关键组件浅析" class="headerlink" title="SpringMVC关键组件浅析"></a>SpringMVC关键组件浅析</h2><p>上面已经完成的快速入门的操作，也在不知不觉中完成的Spring和SpringMVC的整合，我们只需要按照规则去定 义Controller和业务方法就可以。但是在这个过程中，肯定是很多核心功能类参与到其中，这些核心功能类，一 般称为组件。当请求到达服务器时，是哪个组件接收的请求，是哪个组件帮我们找到的Controller，是哪个组件 帮我们调用的方法，又是哪个组件最终解析的视图？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组件</th>
<th>描述</th>
<th>常用组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理器映射器：HandlerMapping</td>
<td>匹配映射路径对应的Handler，返回可执行的处 理器链对象HandlerExecutionChain对象</td>
<td>RequestMappingHandlerMapping</td>
</tr>
<tr>
<td>处理器适配器：HandlerAdapter</td>
<td>匹配HandlerExecutionChain对应的适配器进行处 理器调用，返回视图模型对象</td>
<td>RequestMappingHandlerAdapter</td>
</tr>
<tr>
<td>视图解析器：ViewResolver</td>
<td>对视图模型对象进行解析</td>
<td>InternalResourceViewResolver</td>
</tr>
</tbody>
</table>
</div>
<p>先简单了解一下以上三个重要组件的关系</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819212315576.png" alt="image-20240819212315576"></p>
<p>SpringMVC的默认组件，SpringMVC 在前端控制器 DispatcherServlet加载时，就会进行初始化操作，在进行初始 化时，就会加载SpringMVC默认指定的一些组件，这些默认组件配置在 DispatcherServlet.properties 文件中，该文 件存在与spring-webmvc-5.3.7.jar包下的 org\springframework\web\servlet\DispatcherServlet.properties</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">     org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span><br><span class="line">     org.springframework.web.servlet.function.support.RouterFunctionMapping</span><br><span class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="line">     org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">     org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\</span><br><span class="line">     org.springframework.web.servlet.function.support.HandlerFunctionAdapter</span><br><span class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><span class="line">#省略其他代码</span><br></pre></td></tr></table></figure>
<p>这些默认的组件是在DispatcherServlet中进行初始化加载的，在DispatcherServlet中存在集合存储着这些组件， SpringMVC的默认组件会在 DispatcherServlet 中进行维护，但是并没有存储在与SpringMVC的容器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line">     <span class="comment">//存储处理器映射器</span></span><br><span class="line">     <span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">     <span class="comment">//存储处理器适配器</span></span><br><span class="line">     <span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line">     <span class="comment">//存储视图解析器</span></span><br><span class="line">     <span class="keyword">private</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">     <span class="comment">// ... 省略其他代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置组件代替默认组件，如果不想使用默认组件，可以将替代方案使用Spring Bean的方式进行配置，例如，在 spring-mvc.xml中配置RequestMappingHandlerMapping</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们在Spring容器中配置了HandlerMapping，则就不会在加载默认的HandlerMapping策略了，原理比较简单， DispatcherServlet 在进行HandlerMapping初始化时，先从SpringMVC容器中找是否存在HandlerMapping，如果 存在直接取出容器中的HandlerMapping，在存储到 DispatcherServlet 中的handlerMappings集合中去。</p>
<h1 id="SpringMVC的请求处理"><a href="#SpringMVC的请求处理" class="headerlink" title="SpringMVC的请求处理"></a>SpringMVC的请求处理</h1><h2 id="请求映射路径的配置"><a href="#请求映射路径的配置" class="headerlink" title="请求映射路径的配置"></a>请求映射路径的配置</h2><p>配置映射路径，映射器处理器才能找到Controller的方法资源，目前主流映射路径配置方式就是@RequestMapping</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>相关注解</th>
<th>作用</th>
<th>使用位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>@RequestMapping</td>
<td>设置控制器方法的访问资源路径，可以接收任何请求</td>
<td>方法和类上</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>设置控制器方法的访问资源路径，可以接收GET请求</td>
<td>方法和类上</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>设置控制器方法的访问资源路径，可以接收POST请求</td>
<td>方法和类上</td>
</tr>
</tbody>
</table>
</div>
<p>@RequestMapping注解，主要使用在控制器的方法上，用于标识客户端访问资源路径，常用的属性有value、path 、method、headers、params等。当@RequestMapping只有一个访问路径需要指定时，使用value属性、path属 性或省略value和path，当有多个属性时，value和path不能省略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/show&quot;)</span><span class="comment">//使用value属性指定一个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &#123;&quot;/show&quot;,&quot;/haohao&quot;,&quot;/abc&quot;&#125;)</span><span class="comment">//使用value属性指定多个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/show&quot;)</span><span class="comment">//使用path属性指定一个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(path = &#123;&quot;/show&quot;,&quot;/haohao&quot;,&quot;/abc&quot;&#125;)</span><span class="comment">//使用path属性指定多个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/show&quot;)</span><span class="comment">//如果只设置访问路径时，value和path可以省略</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&#123;&quot;/show&quot;,&quot;/haohao&quot;,&quot;/abc&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当@RequestMapping 需要限定访问方式时，可以通过method属性设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求地址是/show,且请求方式必须是POST才能匹配成功</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/show&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>method的属性值是一个枚举类型，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">     GET,</span><br><span class="line">     HEAD,</span><br><span class="line">     POST,</span><br><span class="line">     PUT,</span><br><span class="line">     PATCH,</span><br><span class="line">     DELETE,</span><br><span class="line">     OPTIONS,</span><br><span class="line">     TRACE;</span><br><span class="line">     <span class="keyword">private</span> <span class="title function_">RequestMethod</span><span class="params">()</span> &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@GetMapping，当请求方式是GET时，我们可以使用@GetMapping替代@RequestMapping</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>@PostMapping，当请求方式是POST时，我们可以使用@PostMapping替代@RequestMapping</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>@RequestMapping 在类上使用，@RequestMapping 、@GetMapping、@PostMapping还可以使用在 Controller类上，使用在类上后，该类所有方法都公用该@RequestMapping设置的属性，访问路径则为类上的映射 地址+方法上的映射地址，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/xxx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, ServletContextAware &#123;</span><br><span class="line">     <span class="meta">@GetMapping(&quot;/aaa&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> ModelAndView <span class="title function_">aaa</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, </span><br><span class="line">ModelAndViewDefiningException &#123;</span><br><span class="line">     	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时的访问路径为：/xxx/aaa</p>
</blockquote>
<h2 id="请求数据的接收"><a href="#请求数据的接收" class="headerlink" title="请求数据的接收"></a>请求数据的接收</h2><ul>
<li>接收普通请求数据，当客户端提交的数据是普通键值对形式时，直接使用同名形参接收即可</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=haohao&amp;age=35</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(String username, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">     System.out.println(username+<span class="string">&quot;==&quot;</span>+age);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当请求参数有特殊格式数据，如日期时</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=haohao&amp;age=<span class="number">35</span>&amp;birthday=<span class="number">1986</span>/<span class="number">01</span>/<span class="number">01</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(String username,<span class="type">int</span> age,Date birthday)</span>&#123;</span><br><span class="line">     System.out.println(username+<span class="string">&quot;==&quot;</span>+age+<span class="string">&quot;==&quot;</span>+birthday);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Date可以正常接收，因为Spring内置的类型解析器，可以识别的日期格式是 yyyy/MM/dd，但是如果我们提交其他 格式，例如：yyyy-MM-dd 时，类型转换会报错，如下：</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819213157347.png" alt="image-20240819213157347"></p>
<p>解决方案，使用@DateTimeFormat 指定日期格式，修改UserController如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(String username,<span class="type">int</span> age,<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date birthday)</span>&#123;</span><br><span class="line">     System.out.println(username+<span class="string">&quot;==&quot;</span>+age+<span class="string">&quot;==&quot;</span>+birthday);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当请求参数的名称与方法参数名不一致时，可以使用@RequestParam注解进行标注</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=haohao&amp;age=<span class="number">35</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestParam(name = &quot;username&quot;,required = true)</span> String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">     System.out.println(name+<span class="string">&quot;==&quot;</span>+age);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接收实体JavaBean属性数据，单个JavaBean数据：提交的参数名称只要与Java的属性名一致，就可以进行自动封装</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=haohao&amp;age=<span class="number">35</span>&amp;hobbies=eat&amp;hobbies=sleep</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> String username;</span><br><span class="line">     <span class="keyword">private</span> Integer age;</span><br><span class="line">     <span class="keyword">private</span> String[] hobbies;</span><br><span class="line">     <span class="keyword">private</span> Date birthday;</span><br><span class="line">     <span class="keyword">private</span> Address address;</span><br><span class="line">     <span class="comment">//... 省略get和set方法 ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(User user)</span>&#123;</span><br><span class="line">     System.out.println(user);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接收实体JavaBean属性数据，嵌套JavaBean数据：提交的参数名称用 . 去描述嵌套对象的属性关系即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=haohao&amp;address.city=tianjin&amp;address.area=jinghai</span><br></pre></td></tr></table></figure>
<ul>
<li>JavaBean中如果有日期数据，且日期格式不符合yyyy/MM/dd时，需要通过@DateTimeFormat指定日期格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=haohao&amp;birthday=<span class="number">1986</span>-<span class="number">11</span>-<span class="number">11</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String[] hobbies;</span><br><span class="line">	<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"> 	<span class="keyword">private</span> Address address;</span><br><span class="line"> 	<span class="comment">//... 省略get和set方法 ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接收数组或集合数据，客户端传递多个同名参数时，可以使用数组接收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hobbies=eat&amp;hobbies=sleep</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(String[] hobbies)</span>&#123;</span><br><span class="line"> 	<span class="keyword">for</span> (String hobby : hobbies) &#123;</span><br><span class="line"> 	System.out.println(hobby);&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接收数组或集合数据，客户端传递多个同名参数时，也可以使用单列集合接收，但是需要使用@RequestParam告知 框架传递的参数是要同名设置的，不是对象属性设置的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hobbies)</span>&#123;</span><br><span class="line">	 <span class="keyword">for</span> (String hobby : hobbies) &#123;</span><br><span class="line"> 	System.out.println(hobby);&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接收数组或集合数据，客户端传递多个不同命参数时，也可以使用Map&lt; String,Object&gt; 进行接收，同样需要用 @RequestParam 进行修饰</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=haohao&amp;age=<span class="number">18</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestParam</span> Map&lt;String,Object&gt; params)</span>&#123;</span><br><span class="line">	 params.forEach((key,value)-&gt;&#123;</span><br><span class="line">	 System.out.println(key+<span class="string">&quot;==&quot;</span>+value);</span><br><span class="line">	 &#125;);</span><br><span class="line">	 <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接收Json数据格式数据，Json数据都是以请求体的方式提交的，且不是原始的键值对格式的，所以我们要使用 @RequestBody注解整体接收该数据。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> 	<span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;haohao&quot;</span><span class="punctuation">,</span></span><br><span class="line">	 <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">	 <span class="attr">&quot;hobbies&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;eat&quot;</span><span class="punctuation">,</span><span class="string">&quot;sleep&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	 <span class="attr">&quot;birthday&quot;</span><span class="punctuation">:</span><span class="string">&quot;1986-01-01&quot;</span><span class="punctuation">,</span></span><br><span class="line">	 <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"> 		<span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;tj&quot;</span><span class="punctuation">,</span></span><br><span class="line"> 		<span class="attr">&quot;area&quot;</span><span class="punctuation">:</span><span class="string">&quot;binhai&quot;</span></span><br><span class="line">	 <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show6</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span>&#123;</span><br><span class="line"> 	System.out.println(body);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Json工具（ jackson ）将Json格式的字符串转化为JavaBean进行操作</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> 	System.out.println(body);</span><br><span class="line"> 	<span class="comment">//获得ObjectMapper</span></span><br><span class="line"> 	<span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"> 	<span class="comment">//将json格式字符串转化成指定的User</span></span><br><span class="line"> 	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(body, User.class);</span><br><span class="line"> 	System.out.println(user);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置RequestMappingHandlerAdapter，指定消息转换器，就不用手动转换json格式字符串了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">		 <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line"> 	System.out.println(user);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收Json数据格式数据，使用Map接收json格式字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestBody</span> Map map)</span>&#123;</span><br><span class="line"> 	System.out.println(map);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Restful风格"><a href="#Restful风格" class="headerlink" title="Restful风格"></a>Restful风格</h3><p>什么是Rest风格？</p>
<p>Rest（Representational State Transfer）表象化状态转变（表述性状态转变），在2000年被提出，基于HTTP、URI 、xml、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构设计。是Web服务的一种新网络应用程序的设计风 格和开发方式。</p>
<p>Restful风格的请求，常见的规则有如下三点：</p>
<ul>
<li>用URI表示某个模块资源，资源名称为名词</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>模块</th>
<th>URI资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户模块 user</td>
<td><a target="_blank" rel="noopener" href="http://localhost/user">http://localhost/user</a></td>
</tr>
<tr>
<td>商品模块 product</td>
<td><a target="_blank" rel="noopener" href="http://localhost/product">http://localhost/product</a></td>
</tr>
<tr>
<td>账户模块 account</td>
<td><a target="_blank" rel="noopener" href="http://localhost/account">http://localhost/account</a></td>
</tr>
<tr>
<td>日志模块 log</td>
<td><a target="_blank" rel="noopener" href="http://localhost/log">http://localhost/log</a></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>用请求方式表示模块具体业务动作，例如：GET表示查询、POST表示插入、PUT表示更新、DELETE表示删除</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>URI资源</th>
<th>请求方式</th>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/user/100">http://localhost/user/100</a></td>
<td>GET</td>
<td>存在URL地址中：100</td>
<td>查询id=100的User数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/user">http://localhost/user</a></td>
<td>POST</td>
<td>存在请求体中Json： {“username”:”haohao”,”age”:18}</td>
<td>插入User数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/user">http://localhost/user</a></td>
<td>PUT</td>
<td>存在请求体中Json： {“id”:100,”username”:”haohao”,”age”:18}</td>
<td>修改id=100的User数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/user/100">http://localhost/user/100</a></td>
<td>DELETE</td>
<td>存在URL地址中：100</td>
<td>删除id=100的User数据</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>用HTTP响应状态码表示结果，国内常用的响应包括三部分：状态码、状态信息、响应数据</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> 	<span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">,</span></span><br><span class="line"> 	<span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line"> 	<span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"> 		<span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;haohao&quot;</span><span class="punctuation">,</span></span><br><span class="line"> 		<span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span></span><br><span class="line"> 	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> 	<span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">300</span><span class="punctuation">,</span></span><br><span class="line"> 	<span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;执行错误&quot;</span><span class="punctuation">,</span></span><br><span class="line"> 	<span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接收Restful风格数据，Restful请求数据一般会在URL地址上携带，可以使用注解 @PathVariable(占位符参数名称)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost/user/100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line"> 	System.out.println(id);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求URL资源地址包含多个参数情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost/user/haohao/18</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user/&#123;username&#125;/&#123;age&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUserByUsernameAndAge</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span> String </span></span><br><span class="line"><span class="params">username,<span class="meta">@PathVariable(&quot;age&quot;)</span> Integer age)</span>&#123;</span><br><span class="line"> 	System.out.println(username+<span class="string">&quot;==&quot;</span>+age);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收文件上传的数据，文件上传的表单需要一定的要求，如下：</p>
<ul>
<li>表单的提交方式必须是POST</li>
<li>表单的enctype属性必须是multipart/form-data</li>
<li>文件上传项需要有name属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myFile&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务器端，由于映射器适配器需要文件上传解析器，而该解析器默认未被注册，所以手动注册</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件上传解析器，注意：id的名字是固定写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><span class="comment">&lt;!--文件的编码格式 默认是ISO8859-1--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSizePerFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1048576&quot;</span>/&gt;</span><span class="comment">&lt;!--上传的每个文件限制的大小 单位字节--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3145728&quot;</span>/&gt;</span><span class="comment">&lt;!--上传文件的总大小--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1048576&quot;</span>/&gt;</span><span class="comment">&lt;!--上传文件的缓存大小--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而CommonsMultipartResolver底层使用的Apache的是Common-fileuplad等工具API进行的文件上传</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用MultipartFile类型接收上传文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/fileUpload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">fileUpload</span><span class="params">(<span class="meta">@RequestBody</span> MultipartFile myFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> 	System.out.println(myFile);</span><br><span class="line"> 	<span class="comment">//获得上传的文件的流对象</span></span><br><span class="line"> 	<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> myFile.getInputStream();</span><br><span class="line"> 	<span class="comment">//使用commons-io存储到C:\haohao\abc.txt位置</span></span><br><span class="line"> 	<span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line"><span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\haohao\\&quot;</span>+myFile.getOriginalFilename());</span><br><span class="line"> 	IOUtils.copy(inputStream,outputStream);</span><br><span class="line"> 	<span class="comment">//关闭资源</span></span><br><span class="line"> 	inputStream.close();</span><br><span class="line"> 	outputStream.close();</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果进行多文件上传的话，则使用MultipartFile数组即可</p>
<ul>
<li><p>接收Http请求头数据，</p>
<p>接收指定名称的请求头</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/headers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headers</span><span class="params">(<span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String acceptEncoding)</span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">&quot;Accept-Encoding:&quot;</span>+acceptEncoding);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    接收所有的请求头信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/headersMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headersMap</span><span class="params">(<span class="meta">@RequestHeader</span> Map&lt;String,String&gt; map)</span>&#123;</span><br><span class="line"> 	map.forEach((k,v)-&gt;&#123;</span><br><span class="line"> 		System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line"> 	&#125;);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得客户端携带的Cookie数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/cookies&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">cookies</span><span class="params">(<span class="meta">@CookieValue(value = &quot;JSESSIONID&quot;,defaultValue = &quot;&quot;)</span> String jsessionid)</span>&#123;</span><br><span class="line"> 	System.out.println(jsessionid);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得转发Request域中数据，在进行资源之间转发时，有时需要将一些参数存储到request域中携带给下一个资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/request1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request1</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line"> 	<span class="comment">//存储数据</span></span><br><span class="line"> 	request.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;haohao&quot;</span>);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;forward:/request2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/request2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request2</span><span class="params">(<span class="meta">@RequestAttribute(&quot;username&quot;)</span> String username)</span>&#123;</span><br><span class="line"> 	System.out.println(username);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>请求参数乱码的解决方案，Spring已经提供好的CharacterEncodingFilter来进行编码过滤</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置全局的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Javaweb常用对象获取"><a href="#Javaweb常用对象获取" class="headerlink" title="Javaweb常用对象获取"></a>Javaweb常用对象获取</h2><p>获得Javaweb常见原生对象，有时在我们的Controller方法中需要用到Javaweb的原生对象，例如：Request、 Response等，我们只需要将需要的对象以形参的形式写在方法上，SpringMVC框架在调用Controller方法时，会自 动传递实参：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/javawebObject&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">javawebObject</span><span class="params">(HttpServletRequest request, HttpServletResponse response, </span></span><br><span class="line"><span class="params">HttpSession session)</span>&#123;</span><br><span class="line"> 	System.out.println(request);</span><br><span class="line"> 	System.out.println(response);</span><br><span class="line"> 	System.out.println(session);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="请求静态资源"><a href="#请求静态资源" class="headerlink" title="请求静态资源"></a>请求静态资源</h3><p>静态资源请求失效的原因，当DispatcherServlet的映射路径配置为 / 的时候，那么就覆盖的Tomcat容器默认的缺省 Servlet，在Tomcat的config目录下有一个web.xml 是对所有的web项目的全局配置，其中有如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>url-pattern配置为 / 的Servlet我们称其为缺省的Servlet，作用是当其他Servlet都匹配不成功时，就找缺省的Servlet ，静态资源由于没有匹配成功的Servlet，所以会找缺省的DefaultServlet，该DefaultServlet具备二次去匹配静态资 源的功能。但是我们配置DispatcherServlet后就将其覆盖掉了，而DispatcherServlet会将请求的静态资源的名称当 成Controller的映射路径去匹配，即静态资源访问不成功了</p>
<p>静态资源请求的三种解决方案：</p>
<p>第一种方案，可以再次激活Tomcat的DefaultServlet，Servlet的url-pattern的匹配优先级是：精确匹配&gt;目录匹配&gt; 扩展名匹配&gt;缺省匹配，所以可以指定某个目录下或某个扩展名的资源使用DefaultServlet进行解析：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二种方式，在spring-mvc.xml中去配置静态资源映射，匹配映射路径的请求到指定的位置去匹配资源</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapping是映射资源路径，location是对应资源所在的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/html/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/html/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>第三种方式，在spring-mvc.xml中去配置&lt; mvc:default-servlet-handler &gt;，该方式是注册了一个 DefaultServletHttpRequestHandler 处理器，静态资源的访问都由该处理器去处理，这也是开发中使用最多的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注解驱动-lt-mvc-annotation-driven-gt-标签"><a href="#注解驱动-lt-mvc-annotation-driven-gt-标签" class="headerlink" title="注解驱动&lt;  mvc:annotation-driven&gt;标签"></a>注解驱动&lt;  mvc:annotation-driven&gt;标签</h2><p>静态资源配置的第二第三种方式我们可以正常访问静态资源了，但是Controller又无法访问了，报错404，即找不到对 应的资源</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819215251862.png" alt="image-20240819215251862"></p>
<p>第二种方式是通过SpringMVC去解析mvc命名空间下的resources标签完成的静态资源解析，第三种方式式通过 SpringMVC去解析mvc命名空间下的default-servlet-handler标签完成的静态资源解析，根据前面所学习的自定义命 名空间的解析的知识，可以发现不管是以上哪种方式，最终都会注册SimpleUrlHandlerMapping</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext context)</span> &#123;</span><br><span class="line"> 	<span class="comment">//创建SimpleUrlHandlerMapping类型的BeanDefinition</span></span><br><span class="line"> 	<span class="type">RootBeanDefinition</span> <span class="variable">handlerMappingDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(SimpleUrlHandlerMapping.class);</span><br><span class="line"> 	<span class="comment">//注册SimpleUrlHandlerMapping的BeanDefinition</span></span><br><span class="line"> 	context.getRegistry().registerBeanDefinition(beanName, handlerMappingDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又结合组件浅析知识点，一旦SpringMVC容器中存在 HandlerMapping 类型的组件时，前端控制器 DispatcherServlet在进行初始化时，就会从容器中获得HandlerMapping ，不在加载 dispatcherServlet.properties 中默认处理器映射器策略，那也就意味着RequestMappingHandlerMapping不会被加载到了。</p>
<p>手动将RequestMappingHandlerMapping也注册到SpringMVC容器中就可以了，这样DispatcherServlet在进行初 始化时，就会从容器中同时获得RequestMappingHandlerMapping存储到DispatcherServlet中名为 handlerMappings的List集合中，对@RequestMapping 注解进行解析。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据上面的讲解，可以总结一下，要想使用@RequestMapping正常映射到资源方法，同时静态资源还能正常访问， 还可以将请求json格式字符串和JavaBean之间自由转换，我们就需要在spring-mvc.xml中尽心如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示配置RequestMappingHandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示配置RequestMappingHandlerAdapter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置DefaultServletHttpRequestHandler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这么复杂繁琐的配置，是不是看上去有点头大？Spring是个”暖男”，将上述配置浓缩成了一个简单的配置标签，那就 是mvc的注解驱动，该标签内部会帮我们注册RequestMappingHandlerMapping、注册 RequestMappingHandlerAdapter并注入Json消息转换器等，上述配置就可以简化成如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mvc注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置DefaultServletHttpRequestHandler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：&lt; mvc:annotation-driven&gt; 标签在不同的版本中，帮我们注册的组件不同，Spring 3.0.X 版本注册是 DefaultAnnotationHandlerMapping 和 AnnotationMethodHandlerAdapter，由于框架的发展，从Spring 3.1.X  开始注册组件变为 RequestMappingHandlerMapping和RequestMappingHandlerAdapter</p>
</blockquote>
<h1 id="SpringMVC的响应处理"><a href="#SpringMVC的响应处理" class="headerlink" title="SpringMVC的响应处理"></a>SpringMVC的响应处理</h1><p>Spring的接收请求的部分我们讲完了，下面在看一下Spring怎么给客户端响应数据，响应数据主要分为两大部分:</p>
<ul>
<li>传统同步方式：准备好模型数据，在跳转到执行页面进行展示，此方式使用越来越少了，基于历史原因，一些旧 项目还在使用；</li>
<li>前后端分离异步方式：前端使用Ajax技术+Restful风格与服务端进行Json格式为主的数据交互，目前市场上几乎 都是此种方式了。</li>
</ul>
<h2 id="传统同步业务数据响应"><a href="#传统同步业务数据响应" class="headerlink" title="传统同步业务数据响应"></a>传统同步业务数据响应</h2><p>传统同步业务在数据响应时，SpringMVC又涉及如下四种形式：</p>
<ul>
<li>请求资源转发；</li>
</ul>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819215701186.png" alt="image-20240819215701186"></p>
<ul>
<li>请求资源重定向；</li>
</ul>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819215724703.png" alt="image-20240819215724703"></p>
<ul>
<li>响应模型数据；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/forward5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">forward5</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line"> 	<span class="comment">//准备JavaBean模型数据</span></span><br><span class="line"> 	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"> 	user.setUsername(<span class="string">&quot;haohao&quot;</span>);</span><br><span class="line"> 	<span class="comment">//设置模型</span></span><br><span class="line"> 	modelAndView.addObject(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"> 	<span class="comment">//设置视图</span></span><br><span class="line"> 	modelAndView.setViewName(<span class="string">&quot;/index.jsp&quot;</span>);</span><br><span class="line"> 	<span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接回写数据给客户端；</li>
</ul>
<p>直接回写数据，直接通过方法的返回值返回给客户端的字符串，但是SpringMVC默认的方法返回值是视图，可以通过 @ResponseBody 注解显示的告知此处的返回值不要进行视图处理，是要以响应体的方式处理的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/response2&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">response2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;Hello haohao!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前后端分离异步业务数据响应"><a href="#前后端分离异步业务数据响应" class="headerlink" title="前后端分离异步业务数据响应"></a>前后端分离异步业务数据响应</h2><p>其实此处的会写数据，跟上面回写数据给客户端的语法方式一样，只不过有如下一些区别：</p>
<ul>
<li>同步方式回写数据，是将数据响应给浏览器进行页面展示的，而异步方式回写数据一般是回写给Ajax引擎的，即 谁访问服务器端，服务器端就将数据响应给谁</li>
<li>同步方式回写的数据，一般就是一些无特定格式的字符串，而异步方式回写的数据大多是Json格式字符串</li>
</ul>
<p>回写普通数据使用@ResponseBody标注方法，直接返回字符串即可，此处不在说明； 回写Json格式的字符串，即将直接拼接Json格式的字符串或使用工具将JavaBean转换成Json格式的字符串回写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/response3&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">response3</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;haohao\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/response4&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">response4</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line"> 	<span class="comment">//创建JavaBean</span></span><br><span class="line"> 	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"> 	user.setUsername(<span class="string">&quot;haohao&quot;</span>);</span><br><span class="line"> 	user.setAge(<span class="number">18</span>);</span><br><span class="line"> 	<span class="comment">//使用Jackson转换成json格式的字符串</span></span><br><span class="line"> 	<span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(user);</span><br><span class="line"> 	<span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在讲解SringMVC接收请求数据时，客户端提交的Json格式的字符串，也是使用Jackson进行的手动转换成JavaBean ，可以当我们使用了@RequestBody时，直接用JavaBean就接收了Json格式的数据，原理其实就是SpringMVC底层 帮我们做了转换，此处@ResponseBody也可以将JavaBean自动给我们转换成Json格式字符串回响应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/response5&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">response5</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line"> 	<span class="comment">//创建JavaBean</span></span><br><span class="line"> 	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"> 	user.setUsername(<span class="string">&quot;haohao&quot;</span>);</span><br><span class="line"> 	user.setAge(<span class="number">18</span>);</span><br><span class="line"> 	<span class="comment">//直接返回User对象</span></span><br><span class="line"> 	<span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ResponseBody注解使用优化，在进行前后端分离开发时，Controller的每个方法都是直接回写数据的，所以每个 方法上都得写@ResponseBody，可以将@ResponseBody写到Controller上，那么该Controller中的所有方法都具备 了返回响应体数据的功能了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span>&#123;</span><br><span class="line"> 	<span class="meta">@GetMapping(&quot;/response7&quot;)</span></span><br><span class="line"> 	<span class="keyword">public</span> ResultInfo <span class="title function_">response7</span><span class="params">()</span> &#123;</span><br><span class="line"> 		<span class="comment">//省略其他代码</span></span><br><span class="line"> 		<span class="keyword">return</span> info;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@GetMapping(&quot;/response5&quot;)</span></span><br><span class="line"> 	<span class="keyword">public</span> User <span class="title function_">response5</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line"> 		<span class="comment">//省略其他代码</span></span><br><span class="line"> 		<span class="keyword">return</span> user;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// ... 省略其他方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步优化，可以使用@RestController替代@Controller和@ResponseBody，@RestController内部具备的这两个 注解的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span>&#123;</span><br><span class="line"> 	<span class="meta">@GetMapping(&quot;/response7&quot;)</span></span><br><span class="line"> 	<span class="keyword">public</span> ResultInfo <span class="title function_">response7</span><span class="params">()</span> &#123;</span><br><span class="line"> 		<span class="comment">//省略其他代码</span></span><br><span class="line"> 		<span class="keyword">return</span> info;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@GetMapping(&quot;/response5&quot;)</span></span><br><span class="line"> 	<span class="keyword">public</span> User <span class="title function_">response5</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line"> 		<span class="comment">//省略其他代码</span></span><br><span class="line"> 		<span class="keyword">return</span> user;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// ... 省略其他方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SpringMVC的拦截器"><a href="#SpringMVC的拦截器" class="headerlink" title="SpringMVC的拦截器"></a>SpringMVC的拦截器</h1><h2 id="拦截器-Interceptor-简介"><a href="#拦截器-Interceptor-简介" class="headerlink" title="拦截器 Interceptor 简介"></a>拦截器 Interceptor 简介</h2><p>SpringMVC的拦截器Interceptor规范，主要是对Controller资源访问时进行拦截操作的技术，当然拦截后可以进行权 限控制，功能增强等都是可以的。拦截器有点类似 Javaweb 开发中的Filter，拦截器与Filter的区别如下图：</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819220144622.png" alt="image-20240819220144622"></p>
<p>由上图，对Filter 和 Interceptor 做个对比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Filter技术</th>
<th>Interceptor技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>技术范畴</td>
<td>Javaweb原生技术</td>
<td>SpringMVC框架技术</td>
</tr>
<tr>
<td>拦截/过滤资源</td>
<td>可以对所有请求都过滤，包括任何Servlet、Jsp、 其他资源等</td>
<td>只对进入了SpringMVC管辖范围的才拦截，主要拦截 Controller请求</td>
</tr>
<tr>
<td>执行时机</td>
<td>早于任何Servlet执行</td>
<td>晚于DispatcherServlet执行</td>
</tr>
</tbody>
</table>
</div>
<p>实现了HandlerInterceptor接口，且被Spring管理的Bean都是拦截器，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"> 	<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HandlerInterceptor接口方法的作用及其参数、返回值详解如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>作用</th>
<th>参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>preHandle</td>
<td>对拦截到的请求进行预处理，返回true放 行执行处理器方法，false不放行</td>
<td>Handler是拦截到的Controller方 法处理器</td>
<td>一旦返回false，代表终止向后 执行，所有后置方法都不执行， 最终方法只执行对应preHandle 返回了true的</td>
</tr>
<tr>
<td>postHandle</td>
<td>在处理器的方法执行后，对拦截到的请求 进行后处理，可以在方法中对模型数据和 视图进行修改</td>
<td>Handler是拦截到的Controller方 法处理器；modelAndView是返 回的模型视图对象</td>
<td>无</td>
</tr>
<tr>
<td>afterCompletion</td>
<td>视图渲染完成后(整个流程结束之后)，进行 最后的处理，如果请求流程中有异常，可 以处理异常对象</td>
<td>Handler是拦截到的Controller方 法处理器；ex是异常对象</td>
</tr>
</tbody>
</table>
</div>
<h2 id="拦截器快速入门"><a href="#拦截器快速入门" class="headerlink" title="拦截器快速入门"></a>拦截器快速入门</h2><p>编写MyInterceptor01实现HandlerInterceptor接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor01</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;Controller方法执行之前...&quot;</span>);</span><br><span class="line"> 		<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//放行</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;Controller方法执行之后...&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;渲染视图结束，整个流程完毕...&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置Interceptor</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> 		<span class="comment">&lt;!--配置对哪些资源进行拦截操作--&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/*&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="拦截器执行顺序"><a href="#拦截器执行顺序" class="headerlink" title="拦截器执行顺序"></a>拦截器执行顺序</h2><p>拦截器三个方法的执行顺序</p>
<p>当每个拦截器都是放行状态时，三个方法的执行顺序如下：</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819220627576.png" alt="image-20240819220627576"></p>
<p>当Interceptor1和Interceptor2处于放行，Interceptor3处于不放行时，三个方法的执行顺序如下：</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819220655263.png" alt="image-20240819220655263"></p>
<p>拦截器执行顺序取决于 interceptor 的配置顺序</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/target&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/*&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="拦截器执行原理"><a href="#拦截器执行原理" class="headerlink" title="拦截器执行原理"></a>拦截器执行原理</h2><p>请求到来时先会使用组件HandlerMapping去匹配Controller的方法（Handler）和符合拦截路径的Interceptor， Handler和多个Interceptor被封装成一个HandlerExecutionChain的对象</p>
<p>HandlerExecutionChain 定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line"> 	<span class="comment">//映射的Controller的方法</span></span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"> 	<span class="comment">//当前Handler匹配的拦截器集合</span></span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"> 	<span class="comment">// ... 省略其他代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DispatcherServlet的doDispatch方法中执行拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line"> 	<span class="comment">//根据请求信息获得HandlerExecutionChain</span></span><br><span class="line"> 	<span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandler(request);</span><br><span class="line"> 	<span class="comment">//获得处理器适配器</span></span><br><span class="line"> 	<span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"> 	<span class="comment">//执行Interceptor的前置方法，前置方法如果返回false，则该流程结束</span></span><br><span class="line"> 	<span class="keyword">if</span> (!mappedHandler.applyPreHandle(request, response)) &#123;</span><br><span class="line"> 		<span class="keyword">return</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//执行handler，一般是HandlerMethod</span></span><br><span class="line"> 	<span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"> 	<span class="comment">//执行后置方法</span></span><br><span class="line"> 	mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line"> 	<span class="comment">//执行最终方法</span></span><br><span class="line"> 	<span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟踪 HandlerExecutionChain的applyPreHandle方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> </span><br><span class="line">Exception &#123;</span><br><span class="line"> 	<span class="comment">//对interceptorList进行遍历,正向遍历,与此同时使用interceptorIndex进行计数</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.interceptorList.size(); <span class="built_in">this</span>.interceptorIndex = i++) &#123;</span><br><span class="line"> 		<span class="comment">//取出每一个Interceptor对象</span></span><br><span class="line"> 		<span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> (HandlerInterceptor)<span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line"> 		<span class="comment">//调用Interceptor的preHandle方法，如果返回false，则直接执行Interceptor的最终方法</span></span><br><span class="line"> 		<span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line"> 			<span class="comment">//执行Interceptor的最终方法</span></span><br><span class="line"> 			<span class="built_in">this</span>.triggerAfterCompletion(request, response, (Exception)<span class="literal">null</span>);</span><br><span class="line"> 			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟踪 HandlerExecutionChain的applyPostHandle方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> </span></span><br><span class="line"><span class="params">ModelAndView mv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 	<span class="comment">//对interceptorList进行遍历，逆向遍历</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"> 		<span class="comment">//取出每一个Interceptor</span></span><br><span class="line"> 		<span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> (HandlerInterceptor)<span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line"> 		<span class="comment">//执行Interceptor的postHandle方法</span></span><br><span class="line"> 		interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟踪HandlerExecutionChain的triggerAfterCompletion方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> Exception ex)</span> &#123;</span><br><span class="line"> 	<span class="comment">//逆向遍历interceptorList，遍历的个数为执行的applyPreHandle次数-1</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"> 		<span class="comment">//取出每一个Interceptor</span></span><br><span class="line"> 		<span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> (HandlerInterceptor)<span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			<span class="comment">//执行Interceptor的afterCompletion方法</span></span><br><span class="line"> 			interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line"> 			logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, var7);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819221030453.png" alt="image-20240819221030453"></p>
<h1 id="SpringMVC的全注解开发"><a href="#SpringMVC的全注解开发" class="headerlink" title="SpringMVC的全注解开发"></a>SpringMVC的全注解开发</h1><h2 id="spring-mvc-xml-中组件转化为注解形式"><a href="#spring-mvc-xml-中组件转化为注解形式" class="headerlink" title="spring-mvc.xml 中组件转化为注解形式"></a>spring-mvc.xml 中组件转化为注解形式</h2><p>跟之前全注解开发思路一致， xml配置文件使用核心配置类替代，xml中的标签使用对应的注解替代</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描web层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置文件上传解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/*&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置DefaultServletHttpRequestHandler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>组件可以通过@ComponentScan注解完成；</li>
<li>文件上传解析器multipartResolver可以通过非自定义Bean的注解配置方式，即@Bean注解完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCConfig</span> &#123;</span><br><span class="line"> 	<span class="meta">@Bean</span></span><br><span class="line"> 	<span class="keyword">public</span> CommonsMultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line"> 		<span class="type">CommonsMultipartResolver</span> <span class="variable">multipartResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line"> 		multipartResolver.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"> 		multipartResolver.setMaxUploadSize(<span class="number">3145728</span>);</span><br><span class="line"> 		multipartResolver.setMaxUploadSizePerFile(<span class="number">1048576</span>);</span><br><span class="line"> 		multipartResolver.setMaxInMemorySize(<span class="number">1048576</span>);</span><br><span class="line"> 		<span class="keyword">return</span> multipartResolver;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; mvc:default-servlet-handler /&gt; 和 &lt; mvc:interceptor &gt; 怎么办呢？SpringMVC 提供了一个注解叫做 @EnableWebMvc，我们看一下源码，内部通过@Import 导入了DelegatingWebMvcConfiguration类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WebMvcConfigurerComposite</span> <span class="variable">configurers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurerComposite</span>();</span><br><span class="line"> 	<span class="comment">//从容器中注入WebMvcConfigurer类型的Bean</span></span><br><span class="line"> 	<span class="meta">@Autowired(required = false)</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line"> 			<span class="built_in">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line"> 		&#125;&#125;</span><br><span class="line"> <span class="comment">//省略其他代码&#125;</span></span><br></pre></td></tr></table></figure>
<p>WebMvcConfigurer类型的Bean会被注入进来，然后被自动调用，所以可以实现WebMvcConfigurer接口，完成一些 解析器、默认Servlet等的指定，WebMvcConfigurer接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"> 	<span class="comment">//配置默认Servet处理器</span></span><br><span class="line"> 	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123; &#125;</span><br><span class="line"> 	<span class="comment">//添加拦截器</span></span><br><span class="line"> 	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; &#125;</span><br><span class="line"> 	<span class="comment">//添加资源处理器</span></span><br><span class="line"> 	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123; &#125;</span><br><span class="line"> 	<span class="comment">//添加视图控制器</span></span><br><span class="line"> 	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123; &#125;</span><br><span class="line"> 	<span class="comment">//配置视图解析器</span></span><br><span class="line"> 	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123; &#125;</span><br><span class="line"> 	<span class="comment">//添加参数解析器</span></span><br><span class="line"> 	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> &#123; &#125;</span><br><span class="line">	<span class="comment">//... 省略其他代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建MyWebMvcConfigurer实现WebMvcConfigurer接口，实现addInterceptors 和configureDefaultServletHandling方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line"> 		<span class="comment">//开启DefaultServlet，可以处理静态资源了</span></span><br><span class="line"> 		configurer.enable();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"> 		<span class="comment">//创建拦截器对象，进行注册</span></span><br><span class="line"> 		<span class="comment">//Interceptor的执行顺序也取决于添加顺序</span></span><br><span class="line"> 		registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor01</span>()).addPathPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在SpringMVC核心配置类上添加@EnableWebMvc注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.controller&quot;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCConfig</span> &#123;</span><br><span class="line"> 	<span class="meta">@Bean</span></span><br><span class="line"> 	<span class="keyword">public</span> CommonsMultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line"> 		<span class="type">CommonsMultipartResolver</span> <span class="variable">multipartResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line"> 		multipartResolver.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"> 		multipartResolver.setMaxUploadSize(<span class="number">3145728</span>);</span><br><span class="line"> 		multipartResolver.setMaxUploadSizePerFile(<span class="number">1048576</span>);</span><br><span class="line"> 		multipartResolver.setMaxInMemorySize(<span class="number">1048576</span>);</span><br><span class="line"> 		<span class="keyword">return</span> multipartResolver;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DispatcherServlet加载核心配置类"><a href="#DispatcherServlet加载核心配置类" class="headerlink" title="DispatcherServlet加载核心配置类"></a>DispatcherServlet加载核心配置类</h2><p>DispatcherServlet在进行SpringMVC配置文件加载时，使用的是以下方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC前端控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--指定springMVC配置文件位置--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--服务器启动就创建--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在是使用SpringMVCConfig核心配置类提替代的spring-mvc.xml，怎么加载呢？参照Spring的 ContextLoaderListener加载核心配置类的做法，定义了一个AnnotationConfigWebApplicationContext，通过 代码注册核心配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationConfigWebApplicationContext</span> <span class="keyword">extends</span> </span><br><span class="line"><span class="title class_">AnnotationConfigWebApplicationContext</span> &#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="title function_">MyAnnotationConfigWebApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line"> 		<span class="comment">//注册核心配置类</span></span><br><span class="line"> 		<span class="built_in">super</span>.register(SpringMVCConfig.class);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定springMVC的applicationContext全限定名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itheima.config.MyAnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="消除web-xml"><a href="#消除web-xml" class="headerlink" title="消除web.xml"></a>消除web.xml</h2><p>目前，几乎消除了配置文件，但是web工程的入口还是使用的web.xml进行配置的，如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC前端控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--指定springMVC的applicationContext全限定名 --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itheima.config.MyAnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--服务器启动就创建--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Servlet3.0环境中，web容器提供了javax.servlet.ServletContainerInitializer接口，实现了该接口后，在对 应的类加载路径的META-INF/services 目录创建一个名为javax.servlet.ServletContainerInitializer的文件， 文件内容指定具体的ServletContainerInitializer实现类，那么，当web容器启动时就会运行这个初始化器做 一些组件内的初始化工作；</li>
<li>基于这个特性，Spring就定义了一个SpringServletContainerInitializer实现了ServletContainerInitializer接 口;</li>
<li>而SpringServletContainerInitializer会查找实现了WebApplicationInitializer的类，Spring又提供了一个 WebApplicationInitializer的基础实现类AbstractAnnotationConfigDispatcherServletInitializer，当我们 编写类继承AbstractAnnotationConfigDispatcherServletInitializer时，容器就会自动发现我们自己的类， 在该类中我们就可以配置Spring和SpringMVC的入口了。</li>
</ul>
<p>按照下面的配置就可以完全省略web.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationConfigDispatcherServletInitializer</span> <span class="keyword">extends</span> </span><br><span class="line"><span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"> 	<span class="comment">//返回的带有@Configuration注解的类用来配置ContextLoaderListener</span></span><br><span class="line"> 	<span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;加载核心配置类创建ContextLoaderListener&quot;</span>);</span><br><span class="line"> 		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ApplicationContextConfig.class&#125;;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//返回的带有@Configuration注解的类用来配置DispatcherServlet</span></span><br><span class="line"> 	<span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;加载核心配置类创建DispatcherServlet&quot;</span>);</span><br><span class="line"> 		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMVCConfig.class&#125;;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//将一个或多个路径映射到DispatcherServlet上</span></span><br><span class="line"> 	<span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SpringMVC的组件原理剖析"><a href="#SpringMVC的组件原理剖析" class="headerlink" title="SpringMVC的组件原理剖析"></a>SpringMVC的组件原理剖析</h1><h2 id="前端控制器初始化"><a href="#前端控制器初始化" class="headerlink" title="前端控制器初始化"></a>前端控制器初始化</h2><p>前端控制器DispatcherServlet是SpringMVC的入口，也是SpringMVC的大脑，主流程的工作都是在此完成的，梳 理一下DispatcherServlet 代码。DispatcherServlet 本质是个Servlet，当配置了 load-on-startup 时，会在服务 器启动时就执行创建和执行初始化init方法，每次请求都会执行service方法 DispatcherServlet 的初始化主要做了两件事：</p>
<ul>
<li>获得了一个 SpringMVC 的 ApplicationContext容器；</li>
<li>注册了 SpringMVC的 九大组件。</li>
</ul>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819221938815.png" alt="image-20240819221938815"></p>
<p>SpringMVC 的ApplicationContext容器创建时机，Servlet 规范的 init(ServletConfig config) 方法经过子类重写 ，最终会调用 FrameworkServlet 抽象类的initWebApplicationContext() 方法，该方法中最终获得 一个根 Spring容器（Spring产生的），一个子Spring容器（SpringMVC产生的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HttpServletBean 的初始化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"> 	<span class="built_in">this</span>.initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FrameworkServlet的initServletBean方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"> 	<span class="built_in">this</span>.webApplicationContext = <span class="built_in">this</span>.initWebApplicationContext();<span class="comment">//初始化ApplicationContext</span></span><br><span class="line"> 	<span class="built_in">this</span>.initFrameworkServlet();<span class="comment">//模板设计模式，供子类覆盖实现，但是子类DispatcherServlet没做使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在initWebApplicationContext方法中体现的父子容器的逻辑关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化ApplicationContext是一个及其关键的代码</span></span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line"> 	<span class="comment">//获得根容器，其实就是通过ContextLoaderListener创建的ApplicationContext</span></span><br><span class="line"> 	<span class="comment">//如果配置了ContextLoaderListener则获得根容器，没配置获得的是null</span></span><br><span class="line"> 	<span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span> </span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(<span class="built_in">this</span>.getServletContext());</span><br><span class="line"> 	<span class="comment">//定义SpringMVC产生的ApplicationContext子容器</span></span><br><span class="line"> 	<span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> 	<span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line"> 		<span class="comment">//==&gt;创建SpringMVC的子容器，创建同时将Spring的创建的rootContext传递了过去</span></span><br><span class="line"> 		wac = <span class="built_in">this</span>.createWebApplicationContext(rootContext);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//将SpringMVC产生的ApplicationContext子容器存储到ServletContext域中</span></span><br><span class="line"> 	<span class="comment">//key名是：org.springframework.web.servlet.FrameworkServlet.CONTEXT.DispatcherServlet</span></span><br><span class="line"> 	<span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line"> 		<span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContextAttributeName();</span><br><span class="line"> 	<span class="built_in">this</span>.getServletContext().setAttribute(attrName, wac);</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>跟进创建子容器的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext </span></span><br><span class="line"><span class="params">parent)</span> &#123;</span><br><span class="line"> 	<span class="comment">//实例化子容器ApplicationContext</span></span><br><span class="line"> 	<span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> </span><br><span class="line">(ConfigurableWebApplicationContext)BeanUtils.instantiateClass(contextClass);</span><br><span class="line"> 	<span class="comment">//设置传递过来的ContextLoaderListener的rootContext为父容器</span></span><br><span class="line"> 	wac.setParent(parent);</span><br><span class="line"> 	<span class="comment">//获得web.xml配置的classpath:spring-mvc.xml</span></span><br><span class="line"> 	<span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> <span class="built_in">this</span>.getContextConfigLocation();</span><br><span class="line"> 	<span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line"> 		<span class="comment">//为子容器设置配置加载路径</span></span><br><span class="line"> 		wac.setConfigLocation(configLocation);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//初始化子容器(就是加载spring-mvc.xml配置的Bean)</span></span><br><span class="line"> 	<span class="built_in">this</span>.configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"> 	<span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子容器中的parent维护着父容器的引用</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819222638761.png" alt="image-20240819222638761"></p>
<p>父容器和子容器概念和关系：</p>
<ul>
<li>父容器：Spring 通过ContextLoaderListener为入口产生的applicationContext容器，内部主要维护的是 applicationContext.xml（或相应配置类）配置的Bean信息；</li>
<li>子容器：SpringMVC通过DispatcherServlet的init() 方法产生的applicationContext容器，内部主要维护的 是spring-mvc.xml（或相应配置类）配置的Bean信息，且内部还通过parent属性维护这父容器的引用。</li>
<li>Bean的检索顺序：根据上面子父容器的概念，可以知道Controller存在与子容器中，而Controller中要注入 Service时，会先从子容器本身去匹配，匹配不成功时在去父容器中去匹配，于是最终从父容器中匹配到的 UserService，这样子父容器就可以进行联通了。但是父容器只能从自己容器中进行匹配，不能从子容器中进 行匹配。</li>
</ul>
<p>注册 SpringMVC的 九大组件，在初始化容器initWebApplicationContext方法中执行了onRefresh方法，进而执 行了初始化策略initStrategies方法，注册了九个解析器组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DispatcherServlet初始化SpringMVC九大组件</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line"> 	<span class="built_in">this</span>.initMultipartResolver(context);<span class="comment">//1、初始化文件上传解析器</span></span><br><span class="line"> 	<span class="built_in">this</span>.initLocaleResolver(context);<span class="comment">//2、初始化国际化解析器</span></span><br><span class="line"> 	<span class="built_in">this</span>.initThemeResolver(context);<span class="comment">//3、初始化模板解析器</span></span><br><span class="line"> 	<span class="built_in">this</span>.initHandlerMappings(context);<span class="comment">//4、初始化处理器映射器</span></span><br><span class="line"> 	<span class="built_in">this</span>.initHandlerAdapters(context);<span class="comment">//5、初始化处理器适配器</span></span><br><span class="line"> 	<span class="built_in">this</span>.initHandlerExceptionResolvers(context);<span class="comment">//6、初始化处理器异常解析器</span></span><br><span class="line"> 	<span class="built_in">this</span>.initRequestToViewNameTranslator(context);<span class="comment">//7、初始化请求视图转换器</span></span><br><span class="line"> 	<span class="built_in">this</span>.initViewResolvers(context);<span class="comment">//8、初始化视图解析器</span></span><br><span class="line"> 	<span class="built_in">this</span>.initFlashMapManager(context);<span class="comment">//9、初始化lashMapManager策略组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 this.initHandlerMappings(context) 为例，进一步看一下初始化处理器映射器的细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义List容器存储HandlerMapping</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line"><span class="comment">//初始化HandlerMapping的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line"> 	<span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;<span class="comment">//初始化集合为null</span></span><br><span class="line"> 	<span class="comment">//detectAllHandlerMappings默认为true，代表是否从所有容器中(父子容器)检测HandlerMapping</span></span><br><span class="line"> 	<span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line"> 		<span class="comment">//从Spring容器中去匹配HandlerMapping</span></span><br><span class="line"> 		Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, </span><br><span class="line">HandlerMapping.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"> 		<span class="comment">//如果从容器中获取的HandlerMapping不为null就加入到事先定义好的handlerMappings容器中</span></span><br><span class="line"> 		<span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"> 			<span class="built_in">this</span>.handlerMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(matchingBeans.values());</span><br><span class="line"> 			AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerMappings);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">//如果从容器中没有获得HandlerMapping，意味着handlerMappings集合是空的</span></span><br><span class="line"> 		<span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line"> 			<span class="comment">//加载默认的HandlerMapping，就是加载DispatcherServlet.properties文件中的键值对</span></span><br><span class="line"> 			<span class="built_in">this</span>.handlerMappings = <span class="built_in">this</span>.getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line"> 		&#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化后，映射信息就已经被封装到 HandlerMapping中了，可以在获取 matchingBeans处打断点验证</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819223250497.png" alt="image-20240819223250497"></p>
<h2 id="前端控制器执行主流程"><a href="#前端控制器执行主流程" class="headerlink" title="前端控制器执行主流程"></a>前端控制器执行主流程</h2><p>上面讲解了一下，当服务器启动时，DispatcherServlet 会执行初始化操作，接下来，每次访问都会执行service 方法，我们先宏观的看一下执行流程，在去研究源码和组件执行细节</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819223345137.png" alt="image-20240819223345137"></p>
<p>FrameworkServlet 复写了service(HttpServletRequest request, HttpServletResponse response) 、 doGet(HttpServletRequest request, HttpServletResponse response)、doPost(HttpServletRequest request, HttpServletResponse response)等方法，这些方法都会调用processRequest方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line"> 	<span class="built_in">this</span>.doService(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步调用了doService方法，该方法内部又调用了doDispatch方法，而SpringMVC 主流程最核心的方法就是 doDispatch 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line"> 	<span class="built_in">this</span>.doDispatch(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doDispatch方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">doDispatch方法源码</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line"> 	<span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line"> 	<span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义处理器执行链对象</span></span><br><span class="line"> 	<span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义模型视图对象</span></span><br><span class="line"> 	<span class="comment">//匹配处理器映射器HandlerMapping，返回处理器执行链对象</span></span><br><span class="line"> 	mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);</span><br><span class="line"> 	<span class="comment">//匹配处理器适配器HandlerAdapter，返回处理器适配器对象</span></span><br><span class="line"> 	<span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"> 	<span class="comment">//执行Interceptor的前置方法preHandle</span></span><br><span class="line"> 	mappedHandler.applyPreHandle(processedRequest, response);</span><br><span class="line"> 	<span class="comment">//处理器适配器执行控制器Handler，返回模型视图对象</span></span><br><span class="line"> 	mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"> 	<span class="comment">//执行Interceptor的后置方法postHandle</span></span><br><span class="line"> 	mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line"> 	<span class="comment">//获取视图渲染视图</span></span><br><span class="line"> 	<span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, </span><br><span class="line">(Exception)dispatchException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过RequestMappingHandlerMapping 和RequestMappingHandlerAdaptor模拟主流程</p>
<h1 id="SpringMVC的异常处理机制"><a href="#SpringMVC的异常处理机制" class="headerlink" title="SpringMVC的异常处理机制"></a>SpringMVC的异常处理机制</h1><h2 id="SpringMVC-异常的处理流程"><a href="#SpringMVC-异常的处理流程" class="headerlink" title="SpringMVC 异常的处理流程"></a>SpringMVC 异常的处理流程</h2><p>异常分为编译时异常和运行时异常，编译时异常我们 try-cache 进行捕获，捕获后自行处理，而运行时异常是不 可预期的，就需要规范编码来避免，在SpringMVC 中，不管是编译异常还是运行时异常，都可以最终由 SpringMVC提供的异常处理器进行统一处理，这样就避免了随时随地捕获处理的繁琐性。</p>
<p>当然除了繁琐之外，我们在进行前后端分离异步开发时，往往返回统一格式的结果给客户端，例如： {“code”:200,”message”:””,”data”:{“username”:”haohao”,”age”:null}}，即使报异常了，也不能把状态码500直 接扔给客户端丢给用户，需要将异常转换成符合上面格式的数据响应给客户端更友好。</p>
<p>SpringMVC 处理异常的思路是，一路向上抛，都抛给前端控制器 DispatcherServlet ，DispatcherServlet 在调 用异常处理器ExceptionResolver进行处理，如下图</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819223637232.png" alt="image-20240819223637232"></p>
<h2 id="SpringMVC-的异常处理方式"><a href="#SpringMVC-的异常处理方式" class="headerlink" title="SpringMVC 的异常处理方式"></a>SpringMVC 的异常处理方式</h2><p>SpringMVC 提供了以下三种处理异常的方式：</p>
<ul>
<li>简单异常处理器：使用SpringMVC 内置的异常处理器处理 SimpleMappingExceptionResolver；</li>
<li>自定义异常处理器：实现HandlerExceptionResolver接口，自定义异常进行处理；</li>
<li>注解方式：使用@ControllerAdvice + @ExceptionHandler 来处理。</li>
</ul>
<p>使用SimpleMappingExceptionResolver处理一些简单异常，配置开启SimpleMappingExceptionResolver， 并指定异常捕获后的处理动作，当发生了异常后，会被 SimpleMappingExceptionResolver 处理，跳转到我们 配置的错误页面error.html给用户进行友好展示</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置简单异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!-- 异常捕获后动作：展示视图 --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultErrorView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/error.html&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以在配置SimpleMappingExceptionResolver时，指定一些参数，例如：异常的类型</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultErrorView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/error.html&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"> 			<span class="comment">&lt;!-- 配置异常类型对应的展示视图 --&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.RuntimeException&quot;</span>&gt;</span>/error.html<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.io.FileNotFoundException&quot;</span>&gt;</span>/io.html<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注解方式配置简单映射异常处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title function_">simpleMappingExceptionResolver</span><span class="params">()</span>&#123;</span><br><span class="line"> 	<span class="comment">//创建SimpleMappingExceptionResolver</span></span><br><span class="line"> 	<span class="type">SimpleMappingExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line"> 	<span class="comment">//设置默认错误展示视图</span></span><br><span class="line"> 	resolver.setDefaultErrorView(<span class="string">&quot;/error.html&quot;</span>);</span><br><span class="line"> 	<span class="comment">//定义Properties设置特殊异常对应的映射视图</span></span><br><span class="line"> 	<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"> 	properties.setProperty(<span class="string">&quot;java.lang.RuntimeException&quot;</span>,<span class="string">&quot;/error.html&quot;</span>);</span><br><span class="line"> 	properties.setProperty(<span class="string">&quot;java.io.FileNotFoundException&quot;</span>,<span class="string">&quot;/io.html&quot;</span>);</span><br><span class="line"> 	resolver.setExceptionMappings(properties);</span><br><span class="line"> 	<span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义异常处理器，实现HandlerExceptionResolver接口自定义异常处理器，可以完成异常逻辑的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandlerExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="comment">//参数Object是当前目标方法处理器对象HandlerMethod</span></span><br><span class="line"> 	<span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, </span></span><br><span class="line"><span class="params">HttpServletResponse httpServletResponse, Object o, Exception e)</span> &#123;</span><br><span class="line"> 		<span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line"> 		modelAndView.setViewName(<span class="string">&quot;/error.html&quot;</span>);</span><br><span class="line"> 		<span class="keyword">return</span> modelAndView;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交给Spring管理异常处理器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.exception.MyHandlerExceptionResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义异常处理器，返回Json格式字符串信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandlerExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, </span></span><br><span class="line"><span class="params">HttpServletResponse httpServletResponse, Object o, Exception e)</span> &#123;</span><br><span class="line"> 		<span class="comment">//编写要返回的json格式的字符串</span></span><br><span class="line"> 		<span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;code\&quot;:0,\&quot;message\&quot;:\&quot;error\&quot;,\&quot;data\&quot;:\&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			httpServletResponse.getWriter().write(jsonStr);</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line"> 			e1.printStackTrace();</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用注解 @ControllerAdvice + @ExceptionHandler 配置异常，@ControllerAdvice 注解本质是一个 @Component，也会被扫描到，与此同时，具备AOP功能，默认情况下对所有的Controller都进行拦截操作， 拦截后干什么呢？就需要在结合@ExceptionHandler、@InitBinder、@ModelAttribute 注解一起使用了，此 处我们讲解的是异常，所以是@ControllerAdvice + @ExceptionHandler的组合形式。</p>
<p>编写全局异常处理器类，使用@ControllerAdvice标注，且@ExceptionHandler指定异常类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"> 	<span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line"> 	<span class="keyword">public</span> ModelAndView <span class="title function_">runtimeHandleException</span><span class="params">(RuntimeException e)</span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;全局异常处理器执行....&quot;</span>+e);</span><br><span class="line"> 		<span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;/error.html&quot;</span>);</span><br><span class="line"> 		<span class="keyword">return</span> modelAndView;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@ExceptionHandler(IOException.class)</span></span><br><span class="line"> 	<span class="meta">@ResponseBody</span></span><br><span class="line"> 	<span class="keyword">public</span> ResultInfo <span class="title function_">ioHandleException</span><span class="params">(IOException e)</span>&#123;</span><br><span class="line"> 		<span class="comment">//模拟一个ResultInfo</span></span><br><span class="line"> 		<span class="type">ResultInfo</span> <span class="variable">resultInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>(<span class="number">0</span>,<span class="string">&quot;IOException&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"> 		<span class="keyword">return</span> resultInfo;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果全局异常处理器响应的数据都是Json格式的字符串的话，可以使用@RestControllerAdvice替代 @ControllerAdvice 和 @ResponseBody</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"> 	<span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line"> 	<span class="keyword">public</span> ResultInfo <span class="title function_">runtimeHandleException</span><span class="params">(RuntimeException e)</span>&#123;</span><br><span class="line"> 		<span class="comment">//模拟一个ResultInfo</span></span><br><span class="line"> 		<span class="type">ResultInfo</span> <span class="variable">resultInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>(<span class="number">0</span>,<span class="string">&quot;RuntimeException&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"> 		<span class="keyword">return</span> resultInfo;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@ExceptionHandler(IOException.class)</span></span><br><span class="line"> 	<span class="keyword">public</span> ResultInfo <span class="title function_">ioHandleException</span><span class="params">(IOException e)</span>&#123;</span><br><span class="line"> 		<span class="comment">//模拟一个ResultInfo</span></span><br><span class="line"> 		<span class="type">ResultInfo</span> <span class="variable">resultInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>(<span class="number">0</span>,<span class="string">&quot;IOException&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"> 		<span class="keyword">return</span> resultInfo;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常处理机制原理剖析"><a href="#异常处理机制原理剖析" class="headerlink" title="异常处理机制原理剖析"></a>异常处理机制原理剖析</h2><p>初始化加载的处理器异常解析器，SpringMVC 的前置控制器在进行初始化的时候，会初始化处理器异常解析器 HandlerExceptionResolver</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化处理器异常解析器</span></span><br><span class="line"><span class="built_in">this</span>.initHandlerExceptionResolvers(context);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerExceptionResolvers</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line"> 	<span class="comment">//从容器中获得HandlerExceptionResolver的Map集合</span></span><br><span class="line"> 	Map&lt;String, HandlerExceptionResolver&gt; matchingBeans = </span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"> 	<span class="comment">//如果容器中没有HandlerExceptionResolver的话，则加载默认的HandlerExceptionResolver</span></span><br><span class="line"> 	<span class="keyword">if</span> (<span class="built_in">this</span>.handlerExceptionResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line"> 		<span class="comment">//从dispatcherServlet.properties中加载</span></span><br><span class="line"> 		<span class="built_in">this</span>.handlerExceptionResolvers = <span class="built_in">this</span>.getDefaultStrategies(context, </span><br><span class="line">HandlerExceptionResolver.class);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载DispatcherServlet.properties中默认的异常处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</span><br><span class="line"> org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line"> org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br></pre></td></tr></table></figure>
<p>配置了自定义的异常处理器后，默认的异常处理器就不会被加载，当配置&lt; mvc:annotation-driven /&gt; 或配置了 注解@EnableWebMvc后，默认异常处理器和自定的处理器异常解析器都会被注册</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819224230749.png" alt="image-20240819224230749"></p>
<p>异常处理器加载完毕后，当发生异常时，就会进行处理，跟踪 DispatcherServlet 的 doDispatch() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line"> 	<span class="type">Object</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//定义异常</span></span><br><span class="line"> 	<span class="keyword">try</span> &#123;</span><br><span class="line"> 		<span class="comment">// ... 省略代码 ...</span></span><br><span class="line"> 	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> 		dispatchException = e;</span><br><span class="line"> 	&#125; <span class="keyword">catch</span> (Throwable te) &#123;</span><br><span class="line"> 		dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, te);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//视图处理、拦截器最终方法调用、异常处理都在该方法内</span></span><br><span class="line"> 	<span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, </span><br><span class="line">(Exception)dispatchException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟踪processDispatchResult方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv, <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 	<span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//定义错误视图标识，默认为false</span></span><br><span class="line"> 	<span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line"> 		<span class="comment">//判断当前捕获的异常是否是ModelAndViewDefiningException类型的异常</span></span><br><span class="line"> 		<span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line"> 			<span class="comment">//获得ModelAndViewDefiningException异常对象中的ModelAndView对象</span></span><br><span class="line"> 			mv = ((ModelAndViewDefiningException)exception).getModelAndView();</span><br><span class="line"> 		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 			<span class="comment">//捕获到其他异常，获得当前发生异常的Handler对象</span></span><br><span class="line"> 			<span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>;</span><br><span class="line"> 			<span class="comment">//执行processHandlerException 方法</span></span><br><span class="line"> 			mv = <span class="built_in">this</span>.processHandlerException(request, response, handler, exception);</span><br><span class="line"> 			<span class="comment">//如果异常处理返回了ModelAndView 则修改错误视图的标识为true</span></span><br><span class="line"> 			errorView = mv != <span class="literal">null</span>;</span><br><span class="line"> 		&#125;&#125;</span><br><span class="line"> <span class="comment">// ... 省略其他代码 ...&#125;</span></span><br></pre></td></tr></table></figure>
<p>跟踪processHandlerException 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">processHandlerException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, </span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 	<span class="type">ModelAndView</span> <span class="variable">exMv</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//定义ModelAndView</span></span><br><span class="line"> 	<span class="comment">//判断处理器异常解析器集合是否是空的</span></span><br><span class="line"> 	<span class="keyword">if</span> (<span class="built_in">this</span>.handlerExceptionResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line"> 		<span class="comment">//遍历处理器异常解析器List集合</span></span><br><span class="line"> 		<span class="type">Iterator</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerExceptionResolvers.iterator();</span><br><span class="line"> 		<span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line"> 			<span class="comment">//取出每一个异常解析器</span></span><br><span class="line"> 			<span class="type">HandlerExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> (HandlerExceptionResolver)var6.next();</span><br><span class="line"> 			<span class="comment">//执行异常解析器的resolveException方法</span></span><br><span class="line"> 			exMv = resolver.resolveException(request, response, handler, ex);</span><br><span class="line"> 			<span class="comment">//只要有一个异常处理器返回ModelAndView 则不在执行后面的异常处理器</span></span><br><span class="line"> 			<span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;</span><br><span class="line"> 				<span class="keyword">break</span>;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125; &#125;</span><br><span class="line"> 	<span class="comment">//如果视图解析器不为null</span></span><br><span class="line"> 	<span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;<span class="keyword">return</span> exMv;</span><br><span class="line"> 	&#125; <span class="keyword">else</span> &#123; <span class="keyword">throw</span> ex; &#125; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="SpringMVC-常用的异常解析器"><a href="#SpringMVC-常用的异常解析器" class="headerlink" title="SpringMVC 常用的异常解析器"></a>SpringMVC 常用的异常解析器</h2><p>SpringMVC 相关的处理器异常解析器继承体系如下：</p>
<p><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/image-20240819224459732.png" alt="image-20240819224459732"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口或类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>HandlerExceptionResolver</td>
<td>异常处理器类的顶级接口，实现了该接口的类都会作为异常处理器类</td>
</tr>
<tr>
<td>MyHandlerExceptionResolver</td>
<td>自定义的处理器类，实现了HandlerExceptionResolver接口</td>
</tr>
<tr>
<td>HandlerExceptionResolverComposite</td>
<td>异常解析器混合器，内部存在集合存储多种异常解析器</td>
</tr>
<tr>
<td>SimpleMappingExceptionResolver</td>
<td>简单映射异常处理器，可以配置异常与对应的错误视图</td>
</tr>
<tr>
<td>ExceptionHandlerExceptionResolver</td>
<td>异常处理器异常解析器，默认会被注册到Spring容器中，@ExceptionHandler方式 异常处理就是该解析器解析的</td>
</tr>
<tr>
<td>DefaultHandlerExceptionResolver</td>
<td>默认处理器异常解析器，所有异常处理器都不匹配时，最后执行的异常处理器</td>
</tr>
<tr>
<td>ResponseStatusExceptionResolver</td>
<td>响应状态异常解析器，结合使用@ResponseStatus标注的异常使用</td>
</tr>
</tbody>
</table>
</div>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">JLY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/73f99711.html">http://example.com/posts/73f99711.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">JLY的小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/Spring-MVC/">Spring MVC</a></div><div class="post_share"><div class="social-share" data-image="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/852513f5970b000c44741ea6751bbf4a.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/655d86b3.html" title="Spring AOP"><img class="cover" src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/778479702dde2d807d711d0623445876.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring AOP</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/655d86b3.html" title="Spring AOP"><img class="cover" src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/778479702dde2d807d711d0623445876.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-20</div><div class="title">Spring AOP</div></div></a></div><div><a href="/posts/6c92115f.html" title="Spring"><img class="cover" src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/51f1d6a7e90c510ac74f0089bcd6c805.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-19</div><div class="title">Spring</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JLY</div><div class="author-info__description">这是一个分享美好事物的地方。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jialuyu1102"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jialuyu1102" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:jialuyu1102@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">2024/08/04, JLY的小站成立啦!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%95%B4%E5%90%88web%E7%8E%AF%E5%A2%83"><span class="toc-number">1.</span> <span class="toc-text">Spring整合web环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#web%E5%B1%82MVC%E6%A1%86%E6%9E%B6%E6%80%9D%E6%83%B3%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">web层MVC框架思想与设计思路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">SpringMVC简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">3.1.</span> <span class="toc-text">SpringMVC快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84Bean"><span class="toc-number">3.2.</span> <span class="toc-text">Controller中访问容器中的Bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">SpringMVC关键组件浅析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">SpringMVC的请求处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">4.1.</span> <span class="toc-text">请求映射路径的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6"><span class="toc-number">4.2.</span> <span class="toc-text">请求数据的接收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Restful%E9%A3%8E%E6%A0%BC"><span class="toc-number">4.2.1.</span> <span class="toc-text">Restful风格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javaweb%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96"><span class="toc-number">4.3.</span> <span class="toc-text">Javaweb常用对象获取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">4.3.1.</span> <span class="toc-text">请求静态资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-lt-mvc-annotation-driven-gt-%E6%A0%87%E7%AD%BE"><span class="toc-number">4.4.</span> <span class="toc-text">注解驱动&lt;  mvc:annotation-driven&gt;标签</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">SpringMVC的响应处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E5%90%8C%E6%AD%A5%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94"><span class="toc-number">5.1.</span> <span class="toc-text">传统同步业务数据响应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%82%E6%AD%A5%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94"><span class="toc-number">5.2.</span> <span class="toc-text">前后端分离异步业务数据响应</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">SpringMVC的拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8-Interceptor-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">拦截器 Interceptor 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">6.2.</span> <span class="toc-text">拦截器快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.3.</span> <span class="toc-text">拦截器执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">拦截器执行原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E7%9A%84%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">7.</span> <span class="toc-text">SpringMVC的全注解开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-mvc-xml-%E4%B8%AD%E7%BB%84%E4%BB%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%B3%A8%E8%A7%A3%E5%BD%A2%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">spring-mvc.xml 中组件转化为注解形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DispatcherServlet%E5%8A%A0%E8%BD%BD%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">DispatcherServlet加载核心配置类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E9%99%A4web-xml"><span class="toc-number">7.3.</span> <span class="toc-text">消除web.xml</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">SpringMVC的组件原理剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.1.</span> <span class="toc-text">前端控制器初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E6%89%A7%E8%A1%8C%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">前端控制器执行主流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">SpringMVC的异常处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">9.1.</span> <span class="toc-text">SpringMVC 异常的处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">SpringMVC 的异常处理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">9.3.</span> <span class="toc-text">异常处理机制原理剖析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">9.4.</span> <span class="toc-text">SpringMVC 常用的异常解析器</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/73f99711.html" title="Spring MVC"><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/852513f5970b000c44741ea6751bbf4a.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring MVC"/></a><div class="content"><a class="title" href="/posts/73f99711.html" title="Spring MVC">Spring MVC</a><time datetime="2024-08-19T23:56:08.000Z" title="发表于 2024-08-20 07:56:08">2024-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/655d86b3.html" title="Spring AOP"><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/778479702dde2d807d711d0623445876.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring AOP"/></a><div class="content"><a class="title" href="/posts/655d86b3.html" title="Spring AOP">Spring AOP</a><time datetime="2024-08-19T23:54:49.000Z" title="发表于 2024-08-20 07:54:49">2024-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6c92115f.html" title="Spring"><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/51f1d6a7e90c510ac74f0089bcd6c805.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/posts/6c92115f.html" title="Spring">Spring</a><time datetime="2024-08-19T15:26:37.000Z" title="发表于 2024-08-19 23:26:37">2024-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/69c3279c.html" title="Git"><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/b8569accbc346130a3fc21c58b1899e3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git"/></a><div class="content"><a class="title" href="/posts/69c3279c.html" title="Git">Git</a><time datetime="2024-08-14T12:58:07.000Z" title="发表于 2024-08-14 20:58:07">2024-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/be4eff35.html" title="Filter &amp;&amp; Listener"><img src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/851c3561c4e8ae210cd56008835c79a6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Filter &amp;&amp; Listener"/></a><div class="content"><a class="title" href="/posts/be4eff35.html" title="Filter &amp;&amp; Listener">Filter &amp;&amp; Listener</a><time datetime="2024-08-14T11:54:05.000Z" title="发表于 2024-08-14 19:54:05">2024-08-14</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2024 By JLY</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" href="categories/Java技术栈/">Java技术栈</a><span class="categoryBar-list-count">19</span><span class="categoryBar-list-descr">学习笔记1</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" href="categories/学习笔记2/">学习笔记2</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">学习笔记2</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" href="categories/学习笔记1/">学习笔记1</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">学习笔记3</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/学习笔记3/">学习笔记3</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4a17b156.html" alt=""><img width="48" height="48" src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/778479702dde2d807d711d0623445876.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-04</span><a class="blog-slider__title" href="posts/4a17b156.html" alt="">Hello World</a><div class="blog-slider__text">hello-world</div><a class="blog-slider__button" href="posts/4a17b156.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/f965df95.html" alt=""><img width="48" height="48" src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/1d9aca4b980f1f73b8e0e83affa95fa1.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-05</span><a class="blog-slider__title" href="posts/f965df95.html" alt="">moudle</a><div class="blog-slider__text">文章模板</div><a class="blog-slider__button" href="posts/f965df95.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/8ed2565f.html" alt=""><img width="48" height="48" src="https://yu-1312265541.cos.ap-nanjing.myqcloud.com/imgs/b589de7e6467d847e8eeae9a92c932bd.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-04</span><a class="blog-slider__title" href="posts/8ed2565f.html" alt="">newPost</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="posts/8ed2565f.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>